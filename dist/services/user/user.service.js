'use strict';

var _models = require('../../../models');

var _models2 = _interopRequireDefault(_models);

var _index = require('../index');

var _util = require('../../../dist/lib/util');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var UserService;

UserService = function UserService() {
  this.accessTokenService = new _index.AccessTokenService();
  this.util = new _util.Util();
  registerInstanceHooks.call(this);
};

UserService.prototype.addUser = function (username, password) {
  return _models2.default.User.create({ username: username, password: password });
};

UserService.prototype.login = function (username, password) {
  var _this = this;

  /**
   * _.retrieve()
   * Added as an instance method in the model to remove properties at an instance level
   *
   */

  return _models2.default.User.findOne({ where: { username: username, password: password } }).then(function (user) {
    if (user && user._retrieve()) {
      user = user._retrieve();
      return _this.accessTokenService.addUserToken(user.id).then(function (accessToken) {
        user.accessToken = accessToken.get();
        return user;
      });
    } else {
      throw _this.util.invalidLoginError();
    }
  });
};

UserService.prototype.find = function (filter) {
  if (!filter) {
    filter = {};
  }
  return _models2.default.User.find(filter).then(function (user) {
    return user._retrieve();
  });
};

UserService.prototype.findMe = function (accessToken) {
  return _models2.default.User.findOne({
    include: [{
      model: _models2.default.accessToken,
      where: { token: accessToken }
    }]
  }).then(function (user) {
    return user._retrieve();
  });
};

function registerInstanceHooks() {
  var _this2 = this;

  _models2.default.User.beforeCreate(function (user, options) {
    if (user.password) {
      return _this2.util.hashPassword(user.password).then(function (hash) {
        user.password = hash;
      });
    }
  });
}

module.exports.UserService = UserService;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2FwcC9zZXJ2aWNlcy91c2VyL3VzZXIuc2VydmljZS5qcyJdLCJuYW1lcyI6WyJVc2VyU2VydmljZSIsImFjY2Vzc1Rva2VuU2VydmljZSIsInV0aWwiLCJyZWdpc3Rlckluc3RhbmNlSG9va3MiLCJjYWxsIiwicHJvdG90eXBlIiwiYWRkVXNlciIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJVc2VyIiwiY3JlYXRlIiwibG9naW4iLCJmaW5kT25lIiwid2hlcmUiLCJ0aGVuIiwidXNlciIsIl9yZXRyaWV2ZSIsImFkZFVzZXJUb2tlbiIsImlkIiwiYWNjZXNzVG9rZW4iLCJnZXQiLCJpbnZhbGlkTG9naW5FcnJvciIsImZpbmQiLCJmaWx0ZXIiLCJmaW5kTWUiLCJpbmNsdWRlIiwibW9kZWwiLCJ0b2tlbiIsImJlZm9yZUNyZWF0ZSIsIm9wdGlvbnMiLCJoYXNoUGFzc3dvcmQiLCJoYXNoIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTs7OztBQUNBOztBQUNBOzs7O0FBRUEsSUFBSUEsV0FBSjs7QUFFQUEsY0FBYyx1QkFBVztBQUN2QixPQUFLQyxrQkFBTCxHQUEwQiwrQkFBMUI7QUFDQSxPQUFLQyxJQUFMLEdBQVksZ0JBQVo7QUFDQUMsd0JBQXNCQyxJQUF0QixDQUEyQixJQUEzQjtBQUNELENBSkQ7O0FBTUFKLFlBQVlLLFNBQVosQ0FBc0JDLE9BQXRCLEdBQWdDLFVBQVNDLFFBQVQsRUFBbUJDLFFBQW5CLEVBQTZCO0FBQzNELFNBQU8saUJBQU9DLElBQVAsQ0FBWUMsTUFBWixDQUFtQixFQUFFSCxrQkFBRixFQUFZQyxrQkFBWixFQUFuQixDQUFQO0FBQ0QsQ0FGRDs7QUFJQVIsWUFBWUssU0FBWixDQUFzQk0sS0FBdEIsR0FBOEIsVUFBU0osUUFBVCxFQUFtQkMsUUFBbkIsRUFBNkI7QUFBQTs7QUFFekQ7Ozs7OztBQU1BLFNBQU8saUJBQU9DLElBQVAsQ0FBWUcsT0FBWixDQUFvQixFQUFFQyxPQUFPLEVBQUVOLGtCQUFGLEVBQVlDLGtCQUFaLEVBQVQsRUFBcEIsRUFDSk0sSUFESSxDQUNDLFVBQUNDLElBQUQsRUFBVTtBQUNkLFFBQUlBLFFBQVFBLEtBQUtDLFNBQUwsRUFBWixFQUE4QjtBQUM1QkQsYUFBT0EsS0FBS0MsU0FBTCxFQUFQO0FBQ0EsYUFBTyxNQUFLZixrQkFBTCxDQUF3QmdCLFlBQXhCLENBQXFDRixLQUFLRyxFQUExQyxFQUNKSixJQURJLENBQ0MsVUFBQ0ssV0FBRCxFQUFpQjtBQUNyQkosYUFBS0ksV0FBTCxHQUFtQkEsWUFBWUMsR0FBWixFQUFuQjtBQUNBLGVBQU9MLElBQVA7QUFDSCxPQUpNLENBQVA7QUFLRCxLQVBELE1BT087QUFDTCxZQUFNLE1BQUtiLElBQUwsQ0FBVW1CLGlCQUFWLEVBQU47QUFDRDtBQUNGLEdBWkksQ0FBUDtBQWFELENBckJEOztBQXVCQXJCLFlBQVlLLFNBQVosQ0FBc0JpQixJQUF0QixHQUE2QixVQUFTQyxNQUFULEVBQWlCO0FBQzVDLE1BQUksQ0FBQ0EsTUFBTCxFQUFhO0FBQ1hBLGFBQVMsRUFBVDtBQUNEO0FBQ0QsU0FBTyxpQkFBT2QsSUFBUCxDQUFZYSxJQUFaLENBQWlCQyxNQUFqQixFQUNKVCxJQURJLENBQ0MsVUFBQ0MsSUFBRDtBQUFBLFdBQVVBLEtBQUtDLFNBQUwsRUFBVjtBQUFBLEdBREQsQ0FBUDtBQUVELENBTkQ7O0FBUUFoQixZQUFZSyxTQUFaLENBQXNCbUIsTUFBdEIsR0FBK0IsVUFBU0wsV0FBVCxFQUFzQjtBQUNuRCxTQUFPLGlCQUFPVixJQUFQLENBQVlHLE9BQVosQ0FBb0I7QUFDekJhLGFBQVMsQ0FBQztBQUNSQyxhQUFPLGlCQUFPUCxXQUROO0FBRVJOLGFBQU8sRUFBRWMsT0FBT1IsV0FBVDtBQUZDLEtBQUQ7QUFEZ0IsR0FBcEIsRUFNTkwsSUFOTSxDQU1ELFVBQUNDLElBQUQ7QUFBQSxXQUFVQSxLQUFLQyxTQUFMLEVBQVY7QUFBQSxHQU5DLENBQVA7QUFPRCxDQVJEOztBQVVBLFNBQVNiLHFCQUFULEdBQWlDO0FBQUE7O0FBQy9CLG1CQUFPTSxJQUFQLENBQVltQixZQUFaLENBQXlCLFVBQUNiLElBQUQsRUFBT2MsT0FBUCxFQUFtQjtBQUMxQyxRQUFJZCxLQUFLUCxRQUFULEVBQW1CO0FBQ2pCLGFBQU8sT0FBS04sSUFBTCxDQUFVNEIsWUFBVixDQUF1QmYsS0FBS1AsUUFBNUIsRUFDSk0sSUFESSxDQUNDLFVBQUNpQixJQUFELEVBQVU7QUFDZGhCLGFBQUtQLFFBQUwsR0FBZ0J1QixJQUFoQjtBQUNELE9BSEksQ0FBUDtBQUlEO0FBQ0YsR0FQRDtBQVFEOztBQUVEQyxPQUFPQyxPQUFQLENBQWVqQyxXQUFmLEdBQTZCQSxXQUE3QiIsImZpbGUiOiJ1c2VyLnNlcnZpY2UuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbW9kZWxzIGZyb20gJy4uLy4uLy4uL21vZGVscyc7XHJcbmltcG9ydCB7IEFjY2Vzc1Rva2VuU2VydmljZSB9IGZyb20gJy4uL2luZGV4JztcclxuaW1wb3J0IHsgVXRpbCB9IGZyb20gJy4uLy4uLy4uL2Rpc3QvbGliL3V0aWwnO1xyXG5cclxudmFyIFVzZXJTZXJ2aWNlO1xyXG5cclxuVXNlclNlcnZpY2UgPSBmdW5jdGlvbigpIHtcclxuICB0aGlzLmFjY2Vzc1Rva2VuU2VydmljZSA9IG5ldyBBY2Nlc3NUb2tlblNlcnZpY2UoKTtcclxuICB0aGlzLnV0aWwgPSBuZXcgVXRpbCgpO1xyXG4gIHJlZ2lzdGVySW5zdGFuY2VIb29rcy5jYWxsKHRoaXMpO1xyXG59O1xyXG5cclxuVXNlclNlcnZpY2UucHJvdG90eXBlLmFkZFVzZXIgPSBmdW5jdGlvbih1c2VybmFtZSwgcGFzc3dvcmQpIHtcclxuICByZXR1cm4gbW9kZWxzLlVzZXIuY3JlYXRlKHsgdXNlcm5hbWUsIHBhc3N3b3JkIH0pO1xyXG59O1xyXG5cclxuVXNlclNlcnZpY2UucHJvdG90eXBlLmxvZ2luID0gZnVuY3Rpb24odXNlcm5hbWUsIHBhc3N3b3JkKSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIF8ucmV0cmlldmUoKVxyXG4gICAqIEFkZGVkIGFzIGFuIGluc3RhbmNlIG1ldGhvZCBpbiB0aGUgbW9kZWwgdG8gcmVtb3ZlIHByb3BlcnRpZXMgYXQgYW4gaW5zdGFuY2UgbGV2ZWxcclxuICAgKlxyXG4gICAqL1xyXG5cclxuICByZXR1cm4gbW9kZWxzLlVzZXIuZmluZE9uZSh7IHdoZXJlOiB7IHVzZXJuYW1lLCBwYXNzd29yZCB9fSlcclxuICAgIC50aGVuKCh1c2VyKSA9PiB7XHJcbiAgICAgIGlmICh1c2VyICYmIHVzZXIuX3JldHJpZXZlKCkpIHtcclxuICAgICAgICB1c2VyID0gdXNlci5fcmV0cmlldmUoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5hY2Nlc3NUb2tlblNlcnZpY2UuYWRkVXNlclRva2VuKHVzZXIuaWQpXHJcbiAgICAgICAgICAudGhlbigoYWNjZXNzVG9rZW4pID0+IHtcclxuICAgICAgICAgICAgdXNlci5hY2Nlc3NUb2tlbiA9IGFjY2Vzc1Rva2VuLmdldCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gdXNlcjtcclxuICAgICAgICB9KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyB0aGlzLnV0aWwuaW52YWxpZExvZ2luRXJyb3IoKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbn07XHJcblxyXG5Vc2VyU2VydmljZS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uKGZpbHRlcikge1xyXG4gIGlmICghZmlsdGVyKSB7XHJcbiAgICBmaWx0ZXIgPSB7fTtcclxuICB9XHJcbiAgcmV0dXJuIG1vZGVscy5Vc2VyLmZpbmQoZmlsdGVyKVxyXG4gICAgLnRoZW4oKHVzZXIpID0+IHVzZXIuX3JldHJpZXZlKCkpO1xyXG59O1xyXG5cclxuVXNlclNlcnZpY2UucHJvdG90eXBlLmZpbmRNZSA9IGZ1bmN0aW9uKGFjY2Vzc1Rva2VuKSB7XHJcbiAgcmV0dXJuIG1vZGVscy5Vc2VyLmZpbmRPbmUoe1xyXG4gICAgaW5jbHVkZTogW3tcclxuICAgICAgbW9kZWw6IG1vZGVscy5hY2Nlc3NUb2tlbixcclxuICAgICAgd2hlcmU6IHsgdG9rZW46IGFjY2Vzc1Rva2VuIH1cclxuICAgIH1dXHJcbiAgfSlcclxuICAudGhlbigodXNlcikgPT4gdXNlci5fcmV0cmlldmUoKSk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiByZWdpc3Rlckluc3RhbmNlSG9va3MoKSB7XHJcbiAgbW9kZWxzLlVzZXIuYmVmb3JlQ3JlYXRlKCh1c2VyLCBvcHRpb25zKSA9PiB7XHJcbiAgICBpZiAodXNlci5wYXNzd29yZCkge1xyXG4gICAgICByZXR1cm4gdGhpcy51dGlsLmhhc2hQYXNzd29yZCh1c2VyLnBhc3N3b3JkKVxyXG4gICAgICAgIC50aGVuKChoYXNoKSA9PiB7XHJcbiAgICAgICAgICB1c2VyLnBhc3N3b3JkID0gaGFzaDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICB9KTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMuVXNlclNlcnZpY2UgPSBVc2VyU2VydmljZTsiXX0=